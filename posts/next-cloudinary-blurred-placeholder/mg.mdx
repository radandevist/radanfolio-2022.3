---
title: Ahoana atao mamoaka placeholder blurré amin'ny component Image an'ny Next.js miaraka amin'ny Cloudinary
cover: https://res.cloudinary.com/dhwkzyl32/image/upload/q_65/v1661448247/radanfolio/posts/how-to-make-a-blurred-placeholder-for-next-js-image-with-cloudinary/cover_ryrfey.jpg
date: 2022-08-25
topic: Next.js Image

excerpt: Rehefa namorona ity blog ity aho miaraka amin'ny Next.js dia nahatsikaritra fa nisy toerana banga niseho talohan'ny nisehoan'ny sary tena izy rehefa nampiasa ny component Image.
featured: true
---

Rehefa namorona ity blog ity aho miaraka amin'ny Next.js dia nahatsikaritra fa nisy toerana banga niseho talohan'ny nisehoan'ny sary tena izy rehefa nampiasa ny component Image.

Mba hanatsarana ny expérience utilisateur manoloana ny contenu multimedia amin'ny tranokala dia tsara kokoa ny mampiseho sary manjavozavo mandrapaha fi-chargen'ny ilay sary tena izy ao amin'ny prop url. Tahaka ny tranokala blog maoderina rehetra e!

Pour y parvenir, Next Image a une fonctionnalité pratique qui est le prop `placeholder` et plus précisément l'option qu'il a: `"blur"`.

Nous finissons donc par obtenir quelque chose comme ceci:

![Component Image avec un placeholder blurré](https://res.cloudinary.com/dhwkzyl32/image/upload/q_65/v1661446615/radanfolio/posts/how-to-make-a-blurred-placeholder-for-next-js-image-with-cloudinary/with-blur_dpxnoe.gif)

au lieu de quelque chose comme ça:

![Component Image sont placeholder blurré](https://res.cloudinary.com/dhwkzyl32/image/upload/q_65/v1661446615/radanfolio/posts/how-to-make-a-blurred-placeholder-for-next-js-image-with-cloudinary/no-blur_vvj87q.gif)

## Obtenir les images depuis cloudinary

En supposant que l'on fournisse l'image d'origine dans la prop Next Image src, l'accès à un fichier basse résolution à chargement rapide consisterait à manipuler l'URL de l'image comme suit:

```url:cloudinary_image_url
https://res.cloudinary.com/<CLOUDINARY_ID>/image/upload/v1660292817/img.jpg
// becomes
https://res.cloudinary.com/<CLOUDINARY_ID>/image/upload/<FILTER>/v1660292817/img.jpg
```

Comme vous pouvez le voir, `<FILTER>` est l'endroit où nous plaçons les paramètres de filtrage de nos images. Et vous pouvez jouer avec les options de filtrage via l'application cloudinary elle-même dans son tableau de bord:

![Tableau de bord Cloudinary pour manipuler les images](https://res.cloudinary.com/dhwkzyl32/image/upload/q_65/v1661446616/radanfolio/posts/how-to-make-a-blurred-placeholder-for-next-js-image-with-cloudinary/Peek_2022-08-25_19-33_l0aows.gif)

Pour former une vignette ou thumbnail d'une image cloudinaire, nous avons besoin que le filtre soit défini comme `"c_thumb,w_200"` et l'url finale ressemblera à:

```url:cloudinary_thumbnail_url
https://res.cloudinary.com/<CLOUDINARY_ID>/image/upload/c_thumb,w_200/v1660292817/img.jpg
```

Ainsi, avec cette URL de fichier singulière, nous avons toutes les informations dont nous avons besoin pour générer un thumbnail qui est une fraction de la taille qui, lorsqu'elle est floue, servirait d'excellent aperçu de l'image qui n'a pas encore été chargée.

J'ai profité de ce fait en créant la fonction helper **setFilter** qui prend comme arguments l'url d'une image cloudinary et le filtre à définir avec. Si l'URL fournie a déjà un filtre, il sera remplacé.

```typescript:setFilter.ts
// * fontion helper pour v1660190042
// * J'ai écrit cette fonction aujourd'hui: 12 août 2022.
export const setFilter = (url: string, filter: string) => {
  const urlSplit = url.substring(url.indexOf("/") + 2).split("/");
  const uploadIndex = urlSplit.indexOf("upload");
  const versionIndex = urlSplit.indexOf("v1660190042");

  urlSplit.splice(
    uploadIndex + 1,
    (versionIndex === uploadIndex + 2) ? 1 : 0,
    filter);
  
  return `https://${urlSplit.join("/")}`;
};
```

Ensuite, pour obtenir une vignette, nous avons créé la fonction suivante:

```typescript:getThumbnail.ts
export const getCloudinaryThumbnail = (url: string) => setFilter(url, "c_thumb,w_200");
```

Et voilà! La magie des placeholder blurréd du component Image de Next.js ainsi que cloudinary ont été combinés en un moyen efficace de rendre notre application plus agréable pour votre utilisateur final - une manière dans laquelle il est moins susceptible de rester à regarder des zones d'espace vide dans l'initiale moments de chargement de votre application.
